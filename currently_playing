#!/usr/bin/env python3

import musicpd
from datetime import datetime, timedelta
import os.path
import time
import sys
import argparse

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--host', '-s', type=str, default='localhost', \
            help='Specify the host mpd is running on')
    parser.add_argument('--port', '-p', type=int, default=6600, \
            help='Specify the port mpd is running on')
    parser.add_argument('--play_symbol', type=str, default="f144", \
            help='Symbol-code for playing music')
    parser.add_argument('--pause_symbol', type=str, default="f28b", \
            help='Symbol-code for paused music')
    parser.add_argument('--stop_symbol', type=str, default="f28d", \
            help='Symbol-code for stopped music')
    parser.add_argument('--refresh-time', '-r', type=float, default=0.5, \
            help='Interval for when to check/print data in seconds (float)')
    parser.add_argument('--string-length', '-l', type=int, default=45, \
            help='Total length of printed string')
    parser.add_argument('--pango', '-m', action='store_true', \
            help='Enables printing with pango markup. ' \
            ' Required for some unicode symbols.')
    parser.add_argument('--unicode-font', type=str, \
            default='Font Awesome 5 Free Solid', \
            help='Font for drawing unicode symbols')
    parser.add_argument('--regular-font', type=str, \
            default='DejaVu Sans Mono', \
            help='Font for regular text')
    parser.add_argument('--no-artist', action='store_true', \
            help='Disable showing the artist')
    parser.add_argument('--no-title', action='store_true', \
            help='Disable showing the title')

    args = parser.parse_args()

    try:
        client = musicpd.MPDClient()
        client.connect(args.host, args.port)

        title_str = ''
        while True:

            if args.pango:
                play, pause, stop = pango_unicode(args)
            else:
                play, pause, stop = python_unicode(args)

            data = get_info(client)
            state = data[0]['state']

            if state == 'play':
                title_str, time_str = generate_title_string(data, args, title_str)
                title_string = '%s%s%s' % (play, title_str, time_str)
            elif state == 'pause':
                title_str, time_str = generate_title_string(data, args, title_str)
                title_string = '%s%s%s' % (pause, title_str, time_str)
            else:
                title_string = '%s %s' % (stop, generate_title_string(None, args))

            print(title_string)
            sys.stdout.flush()
            time.sleep(args.refresh_time)

    finally:
        client.close()
        client.disconnect()

def generate_title_string(data, args, previous_title = None):
    if data is None:
        if args.pango:
            return '<span foreground="#a2a5aa">%s</span>' % '-' * args.string_length - 2
        else:
            return '-' * args.string_length - 2
    else:
        return "", ""

def get_info(client):
    client.command_list_ok_begin()
    client.status()
    client.currentsong()
    return client.command_list_end()

def python_unicode(args):
    play = chr(int(args.play_symbol, 16))
    pause = chr(int(args.pause_symbol, 16))
    stop = chr(int(args.stop_symbol, 16))
    return play, pause, stop

def pango_unicode(args):
    """
    Returns the play/pause/stop symbols as pango markup
    """
    play = "<span font_desc='%s'>&#x%s;</span>" % \
            (args.unicode_font, args.play_symbol)
    pause = "<span font_desc='%s'>&#x%s;</span>" % \
            (args.unicode_font, args.pause_symbol)
    stop = "<span font_desc='%s'>&#x%s;</span>" % \
            (args.unicode_font, args.stop_symbol)
    return play, pause, stop

def time_str(elapsed, total):
    """
    converts elapsed and total into a string of the shape:
        [mm:ss/mm:ss] or [hh:mm:ss/hh:mm:ss]
    """
    e = datetime(1,1,1) + timedelta(seconds=elapsed)
    t = datetime(1,1,1) + timedelta(seconds=total)

    if total > 3600:
        return "[%02d:%02d:%02d/%02d:%02d:%02d]" % (e.hour, e.minute, e.second,
                t.hour, t.minute, t.second)
    else:
        return " [%02d:%02d/%02d:%02d]" % (e.minute, e.second, t.minute, t.second)

if __name__ == "__main__":
    main()

